--- lab/stress_failures/data.table/data.table__fread.R.fmt1.R	2026-02-22 00:19:27.578751137 -0600
+++ lab/stress_failures/data.table/data.table__fread.R.fmt2.R	2026-02-22 00:19:27.578800739 -0600
@@ -219,19 +219,19 @@
     tt <- grep("^\\s+$", na.strings)
     if (length(tt)) {
         msg <- gettextf('na.strings[%d]=="%s" consists only of whitespace, ignoring',
-                        tt[1L], na.strings[tt[1L]])
+            tt[1L], na.strings[tt[1L]])
         if (strip.white) {
             if (all(nzchar(na.strings))) {
                 warningf('%s. Since strip.white=TRUE (default), use na.strings="" to specify that any number of spaces in a string column should be read as <NA>.',
-                         msg)
+                    msg)
             } else {
                 warningf('%s. strip.white==TRUE (default) and "" is present in na.strings, so any number of spaces in string columns will already be read as <NA>.',
-                         msg)
+                    msg)
             }
             na.strings <- na.strings[-tt]
         } else {
             stopf('%s. But strip.white=FALSE. Use strip.white=TRUE (default) together with na.strings="" to turn any number of spaces in string columns into <NA>',
-                  msg)
+                msg)
         }
         # whitespace at the beginning or end of na.strings is checked at C level and is an error there; test 1804
     }
@@ -252,9 +252,9 @@
         if (!grepl(yaml_border_re, first_line)) {
             close(f)
             stopf('Encountered <%s%s> at the first unskipped line (%d), which does not constitute the start to a valid YAML header (expecting something matching regex "%s"); please check your input and try again.',
-                  substr(first_line, 1L, 50L),
-                  if (nchar(first_line) > 50L) '...' else '', 1L + skip,
-                  yaml_border_re)
+                substr(first_line, 1L, 50L),
+                if (nchar(first_line) > 50L) '...' else '', 1L + skip,
+                yaml_border_re)
         }
 
         yaml_comment_re <- '^#'
@@ -265,7 +265,7 @@
             if (!length(this_line)) {
                 close(f)
                 stopf('Reached the end of the file before finding a completion to the YAML header. A valid YAML header is bookended by lines matching the regex "%s". Please double check the input file is a valid csvy.',
-                      yaml_border_re)
+                    yaml_border_re)
             }
             if (grepl(yaml_border_re, this_line)) { break }
             if (grepl(yaml_comment_re, this_line))
@@ -278,7 +278,7 @@
         yaml_names <- names(yaml_header)
         if (verbose) {
             catf('Processed %d lines of YAML metadata with the following top-level fields: %s\n',
-                 n_read, brackify(yaml_names))
+                n_read, brackify(yaml_names))
         }
         # process header first since it impacts how to handle colClasses
         if ('header' %chin% yaml_names) {
@@ -293,11 +293,11 @@
             if (any(null_idx <- vapply_1b(new_types, is.null)))
             new_types <- do.call(c, new_types)
             synonms <- rbindlist(list(character = list(syn = c('character', 'string')), integer = list(syn = c('integer', 'int')), numeric = list(syn = c('numeric', 'number', 'double')), factor = list(syn = c('factor', 'categorical')), integer64 = list(syn = c('integer64', 'int64'))),
-                                 idcol = 'r_type')
+                idcol = 'r_type')
             setkeyv(synonms, 'syn')
             new_types <- synonms[list(new_types)]$r_type
             new_names <- sapply(yaml_header$schema$fields[!null_idx], `[[`,
-                                'name')
+                'name')
 
             if ('col.names' %chin% call_args) {
                 messagef("User-supplied column names in 'col.names' will override those found in YAML metadata.")
@@ -311,13 +311,13 @@
                         new_names[ii] %chin% colClasses[[new_types[ii]]]
                                 }))) {
                         messagef('colClasses dictated by user input and those read from YAML header are in conflict (specifically, for column(s) [%s]); the proceeding assumes the user input was an intentional override and will ignore the type(s) implied by the YAML header; please exclude the column(s) from colClasses if this was unintentional.',
-                                 brackify(new_names[matched_name_idx[!idx_type]]))
+                            brackify(new_names[matched_name_idx[!idx_type]]))
                     }
                 }
                 # only add unmentioned columns
                 for (ii in which(!idx_name)) {
                     colClasses[[new_types[ii]]] <- c(colClasses[[new_types[ii]]],
-                                                     new_names[ii])
+                        new_names[ii])
                 }
             } else {
                 # there are no names to be matched in the data, which fread expects
@@ -376,10 +376,10 @@
         }
     }
     ans <- .Call(CfreadR, input, identical(input, file), sep, dec, quote,
-                 header, nrows, skip, na.strings, strip.white,
-                 blank.lines.skip, comment.char, fill, showProgress, nThread,
-                 verbose, warnings2errors, logical01, logicalYN, select, drop,
-                 colClasses, integer64, encoding, keepLeadingZeros, tz == "UTC")
+        header, nrows, skip, na.strings, strip.white,
+        blank.lines.skip, comment.char, fill, showProgress, nThread,
+        verbose, warnings2errors, logical01, logicalYN, select, drop,
+        colClasses, integer64, encoding, keepLeadingZeros, tz == "UTC")
     if (!length(ans)) {
         return(null.data.table()) # test 1743.308 drops all columns
     }
@@ -399,7 +399,7 @@
     }
 
     colClassesAs <- attr(ans, "colClassesAs",
-                         exact = TRUE) # should only be present if one or more are != ""
+        exact = TRUE) # should only be present if one or more are != ""
     for (j in which(nzchar(colClassesAs))) { # # 1634
         v <- .subset2(ans, j)
         new_class <- colClassesAs[j]
@@ -427,7 +427,7 @@
                 msg_fmt <- gettext("Column '%s' was requested to be '%s' but fread encountered the following error:\n\t%s\nso the column has been left as type '%s'")
             }
             warningf(msg_fmt, names(ans)[j], new_class, conditionMessage(c),
-                     typeof(v), domain = NA)
+                typeof(v), domain = NA)
             v
             },
             error = fun)
@@ -446,8 +446,8 @@
         }
         if (verbose)
         catf(ngettext(length(cols_to_factor), "stringsAsFactors=%s converted %d column: %s\n", "stringsAsFactors=%s converted %d columns: %s\n"),
-             stringsAsFactors, length(cols_to_factor),
-             brackify(names(ans)[cols_to_factor]), domain = NA)
+            stringsAsFactors, length(cols_to_factor),
+            brackify(names(ans)[cols_to_factor]), domain = NA)
         for (j in cols_to_factor) {
             set(ans, j = j, value = as_factor(.subset2(ans, j)))
         }
@@ -473,7 +473,7 @@
             to_split <- lengths(index) == 1L
             if (any(to_split))
             index[to_split] <- sapply(index[to_split], strsplit, split = ",",
-                                      fixed = TRUE)
+                fixed = TRUE)
         } else {
             if (length(index) == 1L) {
                 # setindexv accepts lists, so no [[1]]
@@ -521,6 +521,6 @@
 
 as_raw <- function (x) {
     scan(text = x, what = raw(),
-         quiet = TRUE) # as in read.csv, which ultimately uses src/main/scan.c and strtoraw
+        quiet = TRUE) # as in read.csv, which ultimately uses src/main/scan.c and strtoraw
 }
 
