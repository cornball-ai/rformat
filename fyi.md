<!-- Generated by fyi::use_fyi_md() on 2026-02-28 -->
<!-- Regenerate with: fyi::use_fyi_md("rformat") -->

# fyi: rformat

## Exported Functions (rformat::)

| Function | Arguments |
|----------|-----------|
| `rformat` | code, indent, line_limit, wrap, brace_style, control_braces, expand_if, else_same_line, function_space |
| `rformat_dir` | path, recursive, dry_run, indent, line_limit, wrap, brace_style, control_braces, expand_if, else_same_line, function_space |
| `rformat_file` | path, output, dry_run, indent, line_limit, wrap, brace_style, control_braces, expand_if, else_same_line, function_space |


## Internal Functions (rformat:::)

| Function | Arguments |
|----------|-----------|
| `add_control_braces` | terms, mode, indent_str, line_limit |
| `ast_line_width` | terms, line_num, indent_str |
| `body_is_complete` | terms, body_range |
| `code_width` | line |
| `col_to_charpos` | line, col |
| `collapse_calls` | terms, indent_str, line_limit |
| `compute_indent_at_col` | nesting, line_toks, line_num, break_col |
| `compute_nesting` | terminals, n_lines |
| `display_width` | line |
| `enrich_terminals` | pd, orig_lines |
| `expand_call_if_args` | terms, indent_str, line_limit |
| `extract_expr_text` | lines, tokens, target_indent |
| `find_bare_body_end` | terms, body_start |
| `find_token_pos_in_formatted` | tokens, idx |
| `fix_else_placement` | code |
| `format_blank_lines` | code |
| `format_line_tokens` | tokens, prev_token, prev_prev_token |
| `format_pipeline` | code, indent, wrap, expand_if, brace_style, line_limit, function_space, control_braces |
| `format_tokens` | code, indent, wrap, expand_if, brace_style, line_limit, function_space, control_braces |
| `insert_tokens` | terms, new_rows |
| `make_token` | token, text, out_line, out_order, parent |
| `needs_space` | prev, tok, prev_prev |
| `recompute_nesting` | terms |
| `reformat_function_defs` | terms, indent_str, wrap, brace_style, line_limit, function_space |
| `reformat_inline_if` | terms, indent_str, line_limit |
| `renumber_lines` | terms |
| `restore_truncated_str_const_tokens` | terminals, orig_lines |
| `serialize_tokens` | terms, indent_str, wrap, line_limit |
| `split_toplevel` | code |
| `token_indent_level` | terms, idx |
| `wrap_long_calls` | terms, indent_str, wrap, line_limit |
| `wrap_long_operators` | terms, indent_str, line_limit |


## Options (rformat)

| Option | File | Type |
|--------|------|------|
| `avoids` | format_tokens.R | set |


# Documentation: rformat

## add_control_braces

### Add Control Braces (AST Version)

#### Description

Finds bare control flow bodies (if/for/while/repeat without braces)
and transforms them according to the specified mode.
Modes:
- `TRUE` / `"single"`: Add braces, keep on one line if short enough.
- `"multi"`: Add braces, force multi-line.
- `"next_line"`: Move same-line body to next line (no braces).
- `"same_line"`: Move next-line body to same line; strip single-stmt braces.

#### Usage

```r
add_control_braces(terms, mode = "single", indent_str = "    ", line_limit = 80L)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`mode`**: Control brace mode.
- **`indent_str`**: Indent string (for line width calculations).
- **`line_limit`**: Maximum line width.

#### Value

Updated DataFrame.


## add_one_control_brace

### Add Braces to One Control Flow Statement

#### Description

Add Braces to One Control Flow Statement

#### Usage

```r
add_one_control_brace(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Modified code or NULL if no changes.


## apply_if_parseable

### Apply Transform Only If Output Parses

#### Description

Apply Transform Only If Output Parses

#### Usage

```r
apply_if_parseable(code, fn, ...)
```

#### Arguments

- **`code`**: Code string.
- **`fn`**: Transform function taking `code` as first argument.
- **`...`**: Additional arguments passed to `fn`.

#### Value

Transformed code if parseable, otherwise original code.


## ast_line_width

### Compute Display Width of an Output Line

#### Description

Sums token text widths plus inter-token spaces for a given output line.

#### Usage

```r
ast_line_width(terms, line_num, indent_str)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame (sorted by out_line, out_order).
- **`line_num`**: The output line number.
- **`indent_str`**: Indent string (e.g., `"    "` for 4 spaces).

#### Value

Display width of the line.


## code_width

### Get Tab-Expanded Line Length

#### Description

Returns the display width of a line, with tabs expanded to 8-column stops.

#### Usage

```r
code_width(line)
```

#### Arguments

- **`line`**: A single line of text.

#### Value

Display width of the line.


## col_to_charpos

### Convert Tab-Expanded Column to Character Position

#### Description

R's getParseData() reports columns with tabs expanded to 8-column tab stops.
This function converts such a column back to a character position for use
with substring().

#### Usage

```r
col_to_charpos(line, col)
```

#### Arguments

- **`line`**: A single line of text.
- **`col`**: Tab-expanded column position (1-based).

#### Value

Character position (1-based) in the string.


## collapse_calls

### Collapse Multi-Line Calls (AST Version)

#### Description

Finds multi-line parenthesized groups (function calls, control flow
conditions) that would fit on one line and collapses them by setting
all tokens' `out_line` to the opening line.

#### Usage

```r
collapse_calls(terms, indent_str, line_limit = 80L)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`indent_str`**: Indent string.
- **`line_limit`**: Maximum line length.

#### Value

Updated DataFrame.


## collapse_one_call

### Collapse One Multi-Line Function Call

#### Description

Finds the first multi-line function call that can fit on one line
and collapses it. Skips calls containing comments.

#### Usage

```r
collapse_one_call(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Modified code or NULL if no changes.


## compute_indent_at_col

### Compute Indent at a Column Position

#### Description

Walks tokens on a line up to a given column, tracking braces and parens
exactly as compute_nesting does. Returns the indent level that a
hypothetical continuation line would receive.

#### Usage

```r
compute_indent_at_col(nesting, line_toks, line_num, break_col)
```

#### Arguments

- **`nesting`**: Result from compute_nesting().
- **`line_toks`**: Tokens on the line.
- **`line_num`**: Line number.
- **`break_col`**: Column position to stop at (inclusive).

#### Value

Integer indent level.


## compute_nesting

### Compute Nesting Depth Per Line

#### Description

Shared function used by `format_tokens` and wrap passes to compute
identical depth-based indent levels from the parse tree.

#### Usage

```r
compute_nesting(terminals, n_lines)
```

#### Arguments

- **`terminals`**: Terminal token data frame from `getParseData()`,
ordered by `line1, col1`.
- **`n_lines`**: Number of source lines.

#### Value

Named list with `line_indent`, `line_end_brace`,
  `line_end_paren`, `line_end_pab` (all integer vectors of length
  `n_lines`).


## display_width

### Get Tab-Expanded Line Length

#### Description

Returns the display width of a line, with tabs expanded to 8-column stops.

#### Usage

```r
display_width(line)
```

#### Arguments

- **`line`**: A single line of text.

#### Value

Display width of the line.


## enrich_terminals

### Enrich Terminal Tokens for AST-Based Formatting

#### Description

Parses code and returns an enriched terminal-token DataFrame with
per-token nesting state and output metadata. This is the foundation
of the parse-once architecture: parse once, enrich once, transform
the DataFrame through all passes, serialize to text once at the end.

#### Usage

```r
enrich_terminals(pd, orig_lines)
```

#### Arguments

- **`pd`**: Parse data from `getParseData()`.
- **`orig_lines`**: Original source lines (split by newline).

#### Value

Enriched terminal-token DataFrame with added columns:
  `out_line`, `out_order`, `out_text`, `brace_depth`, `paren_depth`,
  `pab`, `nesting_level`.


## expand_call_if_args

### Expand Bare If-Else in Function Call Arguments (AST Version)

#### Description

Finds bare `if (cond) expr else expr` arguments inside function calls
on overlong lines and expands them to braced multi-line form.

#### Usage

```r
expand_call_if_args(terms, indent_str = "    ", line_limit = 80L)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`indent_str`**: Indent string.
- **`line_limit`**: Maximum line width.

#### Value

Updated DataFrame.


## expand_one_call_if_arg

### Expand One Bare If-Else Argument in a Function Call

#### Description

Finds the first bare if-else argument inside a function call on a line
exceeding the line limit and expands it to braced multi-line form.

#### Usage

```r
expand_one_call_if_arg(code, line_limit = 80L)
```

#### Arguments

- **`code`**: Code string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Modified code or NULL if no changes.


## extract_expr_text

### Extract Expression Text from Source Lines

#### Description

Extract original text for a multi-line expression and re-indent it.

#### Usage

```r
extract_expr_text(lines, tokens, target_indent)
```

#### Arguments

- **`lines`**: Source code lines.
- **`tokens`**: Token data frame for the expression.
- **`target_indent`**: Target indentation string for continuation lines.

#### Value

Expression text with first line unindented, continuation lines re-indented.


## find_bare_body_end

### Check if a Body Token Range is a Complete Statement

#### Description

Returns FALSE if the body has unclosed parens/brackets or ends
with an operator that expects a continuation (assignment, binary ops).

#### Usage

```r
find_bare_body_end(terms, body_start)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`body_range`**: Integer vector of row indices for the body.

#### Value

TRUE if the body is a complete, self-contained statement.


## find_token_pos_in_formatted

### Find Token Position in Formatted Line Output

#### Description

Computes the 1-based character position where the token at index `idx`
starts in the output of `format_line_tokens(tokens)`. This replays the
spacing logic to determine the exact output column.

#### Usage

```r
find_token_pos_in_formatted(tokens, idx)
```

#### Arguments

- **`tokens`**: Data frame of tokens for one line (ordered by col1).
- **`idx`**: Index into `tokens` of the target token.

#### Value

1-based character position of that token in the formatted output.


## fix_else_placement

### Fix Else Placement

#### Description

Ensures `else` appears on the same line as the closing brace.

#### Usage

```r
fix_else_placement(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Code with corrected else placement.


## format_blank_lines

### Format Blank Lines

#### Description

Normalize blank lines between code blocks.

#### Usage

```r
format_blank_lines(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Code with normalized blank lines.


## format_line_tokens

### Format Tokens on a Single Line

#### Description

Format Tokens on a Single Line

#### Usage

```r
format_line_tokens(tokens, prev_token = NULL, prev_prev_token = NULL)
```

#### Arguments

- **`tokens`**: Data frame of tokens for one line.
- **`prev_token`**: Optional token to treat as the previous token when
formatting a token subset (e.g., suffix after a collapsed call).
- **`prev_prev_token`**: Optional token before prev_token for unary detection.

#### Value

Formatted line content (no leading whitespace).


## format_pipeline

### AST-Based Format Pipeline

#### Description

Single-pass pipeline: parse once, enrich the terminal DataFrame, run
all transforms as DataFrame operations, serialize to text once.

#### Usage

```r
format_pipeline(code, indent, wrap, expand_if, brace_style, line_limit,
                function_space = FALSE, control_braces = FALSE)
```

#### Arguments

- **`code`**: Code string for one top-level expression.
- **`indent`**: Indent string or integer.
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`expand_if`**: Whether to expand all inline if-else.
- **`brace_style`**: `"kr"` or `"allman"`.
- **`line_limit`**: Maximum line length.
- **`function_space`**: Add space after `function`.
- **`control_braces`**: Control brace mode.

#### Value

Formatted code string.


## format_tokens

### Format R Code Using Token-Based Parsing

#### Description

Internal function to format R code using getParseData tokens.
Calculates proper indentation based on nesting depth.

#### Usage

```r
format_tokens(code, indent = 4L, wrap = "paren", expand_if = FALSE,
              brace_style = "kr", line_limit = 80L, function_space = FALSE,
              control_braces = FALSE)
```

#### Arguments

- **`code`**: Character string of R code.
- **`indent`**: Integer for spaces (default 4), or character string for
literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`wrap`**: Continuation style: `"paren"` (default) aligns to opening
parenthesis, `"fixed"` uses 8-space indent.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`brace_style`**: Brace placement: `"kr"` (same line) or `"allman"` (new line).
- **`line_limit`**: Maximum line length before wrapping (default 80).
- **`function_space`**: If TRUE, add space before `(` in function definitions.
- **`control_braces`**: If TRUE, add braces to bare one-line control flow bodies.

#### Value

Formatted code as character string.


## insert_tokens

### Insert Synthetic Tokens into the DataFrame

#### Description

Adds new token rows (e.g., for brace insertion). New tokens get unique IDs
starting from `max(existing_id) + 1`.

#### Usage

```r
insert_tokens(terms, new_rows)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`new_rows`**: Data frame of new tokens to insert. Must have at minimum:
`token`, `out_text`, `out_line`, `out_order`. Other columns will be
filled with defaults.

#### Value

Updated DataFrame with new rows appended.


## is_parseable_code

### Parse Gate for Transform Passes

#### Description

Parse Gate for Transform Passes

#### Usage

```r
is_parseable_code(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

TRUE if code parses, FALSE otherwise.


## make_token

### Create a Synthetic Token Row

#### Description

Helper to build a single token row for insertion.

#### Usage

```r
make_token(token, text, out_line, out_order, parent = 0L)
```

#### Arguments

- **`token`**: Token type string (e.g., `"'{'"`, `"'}'"`, `"','"`)
- **`text`**: Token text (e.g., `"{"`, `"}"`, `","`)
- **`out_line`**: Target output line.
- **`out_order`**: Sort order within the line.
- **`parent`**: Parent node ID (default 0).

#### Value

Single-row data frame.


## needs_space

### Determine If Space Needed Between Tokens

#### Description

Determine If Space Needed Between Tokens

#### Usage

```r
needs_space(prev, tok, prev_prev = NULL)
```

#### Arguments

- **`prev`**: Previous token (data frame row).
- **`tok`**: Current token (data frame row).
- **`prev_prev`**: Token before prev (data frame row or NULL), for unary detection.

#### Value

Logical.


## recompute_nesting

### Recompute Nesting State After Structural Changes

#### Description

Re-walks terminals and refreshes `brace_depth`, `paren_depth`, `pab`,
and `nesting_level` columns. Call after brace insertion, token removal,
or any structural transform.

#### Usage

```r
recompute_nesting(terms)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.

#### Value

Updated DataFrame with refreshed nesting columns.


## reformat_function_defs

### Reformat Function Definitions (AST Version)

#### Description

Rewrites named function signatures to fit within the line limit.
Short signatures go on one line; long ones wrap at commas with
paren-aligned or fixed continuation indent. Operates on the
DataFrame directly, avoiding the serialize/re-parse cycle that
caused idempotency oscillation.

#### Usage

```r
reformat_function_defs(terms, indent_str = "    ", wrap = "paren",
                       brace_style = "kr", line_limit = 80L,
                       function_space = FALSE)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`indent_str`**: Indent string (e.g., `"    "`).
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`brace_style`**: `"kr"` or `"allman"`.
- **`line_limit`**: Maximum line length.
- **`function_space`**: Whether to add space after `function`.

#### Value

Updated DataFrame.


## reformat_inline_if

### Reformat Inline If-Else Assignments (AST Version)

#### Description

Finds `var <- if (cond) true_expr else false_expr` patterns and
expands them to braced multi-line form with duplicated assignment:
if (cond) {
var <- true_expr
} else {
var <- false_expr

#### Usage

```r
reformat_inline_if(terms, indent_str = "    ", line_limit = 0L)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`indent_str`**: Indent string.
- **`line_limit`**: Maximum line width. Use 0 to expand all.

#### Value

Updated DataFrame.


## reformat_one_function

### Reformat One Function Definition

#### Description

Uses R Core continuation style: args on one line if they fit,
otherwise wrap with continuation indent.

#### Usage

```r
reformat_one_function(
  code,
  wrap = "paren",
  brace_style = "kr",
  line_limit = 80L
)
```

#### Arguments

- **`code`**: Code string.
- **`wrap`**: Continuation style: `"paren"` aligns to opening parenthesis,
`"fixed"` uses 8-space indent.
- **`brace_style`**: Brace placement: `"kr"` (same line) or `"allman"` (new line).
- **`line_limit`**: Maximum line length before wrapping (default 80).

#### Value

Modified code or NULL if no changes.


## reformat_one_inline_if

### Reformat One Inline If-Else Statement

#### Description

Reformat One Inline If-Else Statement

#### Usage

```r
reformat_one_inline_if(code, line_limit = 0L)
```

#### Arguments

- **`code`**: Code string.
- **`line_limit`**: Only expand if-else on lines exceeding this limit.
Use 0 to expand all inline if-else.

#### Value

Modified code or NULL if no changes.


## renumber_lines

### Renumber Output Lines Sequentially

#### Description

After transforms that insert or remove lines, renumber `out_line` so
values are sequential starting from 1, preserving relative order and
gaps for blank lines.

#### Usage

```r
renumber_lines(terms)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.

#### Value

Updated DataFrame with renumbered `out_line`.


## restore_truncated_str_const_tokens

### Restore Truncated String Constant Token Text

#### Description

`utils::getParseData()` truncates long `STR_CONST` token text. Reconstruct the
original literal from source lines so token-based rewrite passes can round-trip
long strings without introducing parse-invalid placeholders.

#### Usage

```r
restore_truncated_str_const_tokens(terminals, orig_lines)
```

#### Arguments

- **`terminals`**: Terminal token data frame from `getParseData()`.
- **`orig_lines`**: Original source lines.

#### Value

`terminals` with long `STR_CONST` text restored.


## rformat_dir

### Format R Files in Directory

#### Description

Format all R files in a directory.

#### Usage

```r
rformat_dir(path = ".", recursive = TRUE, dry_run = FALSE, indent = 4L,
            line_limit = 80L, wrap = "paren", brace_style = "kr",
            control_braces = FALSE, expand_if = FALSE, else_same_line = TRUE,
            function_space = FALSE)
```

#### Arguments

- **`path`**: Path to directory.
- **`recursive`**: If TRUE, process subdirectories.
- **`dry_run`**: If TRUE, report changes without writing.
- **`indent`**: Indentation per level: integer for spaces (default 4), or
character string for literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`line_limit`**: Maximum line length before wrapping (default 80).
- **`wrap`**: Continuation style for long function signatures: `"paren"`
(default) aligns to opening parenthesis, `"fixed"` uses 8-space indent.
- **`brace_style`**: Brace placement for function definitions: `"kr"` (default)
puts opening brace on same line as `) {`, `"allman"` puts it on a new line.
- **`control_braces`**: If TRUE, add braces to bare one-line control flow
bodies. Default FALSE matches R Core majority style.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`else_same_line`**: If TRUE (default), fix `}\nelse` to `} else {`.
- **`function_space`**: If TRUE, add space before `(` in function definitions:
`function (x)` instead of `function(x)`. Default FALSE matches 96% of
R Core source code.

#### Value

Invisibly returns vector of modified file paths.

#### Examples

```r
# Format all R files in a directory (dry run)
d <- tempfile()
dir.create(d)
writeLines("x<-1", file.path(d, "test.R"))
rformat_dir(d, dry_run = TRUE)

# Format and overwrite
rformat_dir(d)
unlink(d, recursive = TRUE)
```


## rformat_file

### Format R File

#### Description

Format an R file in place or write to a new file.

#### Usage

```r
rformat_file(path, output = NULL, dry_run = FALSE, indent = 4L,
             line_limit = 80L, wrap = "paren", brace_style = "kr",
             control_braces = FALSE, expand_if = FALSE, else_same_line = TRUE,
             function_space = FALSE)
```

#### Arguments

- **`path`**: Path to R file.
- **`output`**: Optional output path. If NULL, overwrites input file.
- **`dry_run`**: If TRUE, return formatted code without writing.
- **`indent`**: Indentation per level: integer for spaces (default 4), or
character string for literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`line_limit`**: Maximum line length before wrapping (default 80).
- **`wrap`**: Continuation style for long function signatures: `"paren"`
(default) aligns to opening parenthesis, `"fixed"` uses 8-space indent.
- **`brace_style`**: Brace placement for function definitions: `"kr"` (default)
puts opening brace on same line as `) {`, `"allman"` puts it on a new line.
- **`control_braces`**: If TRUE, add braces to bare one-line control flow
bodies. Default FALSE matches R Core majority style.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`else_same_line`**: If TRUE (default), fix `}\nelse` to `} else {`.
- **`function_space`**: If TRUE, add space before `(` in function definitions:
`function (x)` instead of `function(x)`. Default FALSE matches 96% of
R Core source code.

#### Value

Invisibly returns formatted code.

#### Examples

```r
# Format a file (dry run to see result without writing)
f <- tempfile(fileext = ".R")
writeLines("x<-1+2", f)
rformat_file(f, dry_run = TRUE)

# Format and overwrite
rformat_file(f)
readLines(f)
unlink(f)
```


## rformat

### Format R Code

#### Description

Format R code string according to base R style conventions.

#### Usage

```r
rformat(code, indent = 4L, line_limit = 80L, wrap = "paren",
        brace_style = "kr", control_braces = FALSE, expand_if = FALSE,
        else_same_line = TRUE, function_space = FALSE)
```

#### Arguments

- **`code`**: Character string of R code to format.
- **`indent`**: Indentation per level: integer for spaces (default 4), or
character string for literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`line_limit`**: Maximum line length before wrapping (default 80).
- **`wrap`**: Continuation style for long function signatures: `"paren"`
(default) aligns to opening parenthesis, `"fixed"` uses 8-space indent.
- **`brace_style`**: Brace placement for function definitions: `"kr"` (default)
puts opening brace on same line as `) {`, `"allman"` puts it on a new line.
- **`control_braces`**: If TRUE, add braces to bare one-line control flow
bodies (e.g., `if (x) y` becomes `if (x) { y }`). Default FALSE
matches R Core source code where 59% of control flow bodies are bare.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`else_same_line`**: If TRUE (default), fix `}\nelse` to `} else {` on
the same line. Matches R Core source code where 70% use same-line else.
- **`function_space`**: If TRUE, add space before `(` in function definitions:
`function (x)` instead of `function(x)`. Default FALSE matches 96% of
R Core source code.

#### Value

Formatted code as a character string.

#### Examples

```r
rformat("x<-1+2")
rformat("if(x>0){y<-1}")
# Expand inline if-else
rformat("x <- if (a) b else c", expand_if = TRUE)
# Allman brace style (legacy)
rformat("f <- function(x) { x }", brace_style = "allman")
```


## serialize_tokens

### Serialize Enriched Tokens to Formatted Code

#### Description

Converts the enriched terminal DataFrame to a formatted code string.
This is the final step: tokens are emitted in `(out_line, out_order)`
order with proper indentation and spacing.

#### Usage

```r
serialize_tokens(terms, indent_str, wrap = "paren", line_limit = 80L)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`indent_str`**: Indent string (e.g., `"    "` for 4 spaces).
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`line_limit`**: Maximum line length.

#### Value

Formatted code string.


## split_toplevel

### Split Code into Top-Level Expressions

#### Description

Parses code to find top-level expressions, returning a list of chunks.
Each chunk is either an expression (code string) or an inter-expression
gap (comments, blank lines). Chunks concatenate back to the original.

#### Usage

```r
split_toplevel(code)
```

#### Arguments

- **`code`**: Character string of R code.

#### Value

List of `list(text = "...", is_expr = TRUE/FALSE)` pairs.


## token_indent_level

### Compute Indent Level for a Token

#### Description

Returns the depth-based indent level that should apply to a token's line.
For closing tokens (`}`, `)`, `]`), the indent is one less than the token's
own nesting level (they outdent to match their opening counterpart).

#### Usage

```r
token_indent_level(terms, idx)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`idx`**: Index of the token (must be first on its line for indent).

#### Value

Integer indent level.


## wrap_long_calls

### Wrap Long Function Calls at Commas (AST Version)

#### Description

Finds single-line function calls on overlong lines and wraps them at
commas. Continuation lines get depth-based indentation (or paren-aligned
if `wrap = "paren"`).

#### Usage

```r
wrap_long_calls(terms, indent_str, wrap = "paren", line_limit = 80L)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`indent_str`**: Indent string.
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`line_limit`**: Maximum line length.

#### Value

Updated DataFrame.


## wrap_long_operators

### Wrap Long Lines at Operators (AST Version)

#### Description

Finds overlong lines and breaks them after logical operators (`||`, `&&`,
`|`, `&`). Continuation lines get depth-based indentation.

#### Usage

```r
wrap_long_operators(terms, indent_str, line_limit = 80L)
```

#### Arguments

- **`terms`**: Enriched terminal DataFrame.
- **`indent_str`**: Indent string.
- **`line_limit`**: Maximum line length.

#### Value

Updated DataFrame.


## wrap_one_long_call

### Wrap One Long Function Call

#### Description

Finds the first single-line function call that exceeds the line limit
and wraps it at commas with paren-aligned continuation.

#### Usage

```r
wrap_one_long_call(code, wrap = "paren", indent = 4L, line_limit = 80L)
```

#### Arguments

- **`code`**: Code string.
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`indent`**: Indent size (integer) or string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Modified code or NULL if no changes.


## wrap_one_long_operator

### Wrap One Long Line at an Operator

#### Description

Finds the first line exceeding the limit that contains a top-level
logical operator and wraps there. The operator stays at the end of the
first line, continuation is aligned to the first operand.

#### Usage

```r
wrap_one_long_operator(code, indent = 4L, line_limit = 80L)
```

#### Arguments

- **`code`**: Code string.
- **`indent`**: Indent size (integer) or string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Modified code or NULL if no changes.


