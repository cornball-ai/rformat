<!-- Generated by fyi::use_fyi_md() on 2026-02-24 -->
<!-- Regenerate with: fyi::use_fyi_md("rformat") -->

# fyi: rformat

## Exported Functions (rformat::)

| Function | Arguments |
|----------|-----------|
| `rformat` | code, indent, wrap, expand_if, brace_style, line_limit, function_space |
| `rformat_dir` | path, recursive, dry_run, indent, wrap, expand_if, brace_style, line_limit, function_space |
| `rformat_file` | path, output, dry_run, indent, wrap, expand_if, brace_style, line_limit, function_space |


## Internal Functions (rformat:::)

| Function | Arguments |
|----------|-----------|
| `add_control_braces` | code |
| `add_one_control_brace` | code |
| `apply_if_parseable` | code, fn, ... |
| `col_to_charpos` | line, col |
| `collapse_calls` | code |
| `collapse_one_call` | code |
| `compute_indent_at_col` | nesting, line_toks, line_num, break_col |
| `compute_nesting` | terminals, n_lines |
| `display_width` | line |
| `expand_call_if_args` | code, line_limit |
| `expand_one_call_if_arg` | code, line_limit |
| `extract_expr_text` | lines, tokens, target_indent |
| `find_token_pos_in_formatted` | tokens, idx |
| `fix_else_placement` | code |
| `format_blank_lines` | code |
| `format_line_tokens` | tokens, prev_token, prev_prev_token |
| `format_pipeline` | code, indent, wrap, expand_if, brace_style, line_limit, function_space |
| `format_tokens` | code, indent, wrap, expand_if, brace_style, line_limit, function_space |
| `is_parseable_code` | code |
| `needs_space` | prev, tok, prev_prev |
| `reformat_function_defs` | code, wrap, brace_style, line_limit |
| `reformat_inline_if` | code, line_limit |
| `reformat_one_function` | code, wrap, brace_style, line_limit |
| `reformat_one_inline_if` | code, line_limit |
| `restore_truncated_str_const_tokens` | terminals, orig_lines |
| `split_toplevel` | code |
| `wrap_long_calls` | code, wrap, indent, line_limit |
| `wrap_long_operators` | code, indent, line_limit |
| `wrap_one_long_call` | code, wrap, indent, line_limit |
| `wrap_one_long_operator` | code, indent, line_limit |


## Options (rformat)

| Option | File | Type |
|--------|------|------|
| `avoids` | format_tokens.R | set |


# Documentation: rformat

## add_control_braces

### Add Braces to One-Liner Control Flow

#### Description

Adds braces to single-statement `if`, `for`, `while` bodies:
`if (x) y` becomes `if (x) { y }`.
Does not modify `if`/`else` used as expressions (value-producing).

#### Usage

```r
add_control_braces(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Code with braces added.


## add_one_control_brace

### Add Braces to One Control Flow Statement

#### Description

Add Braces to One Control Flow Statement

#### Usage

```r
add_one_control_brace(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Modified code or NULL if no changes.


## apply_if_parseable

### Apply Transform Only If Output Parses

#### Description

Apply Transform Only If Output Parses

#### Usage

```r
apply_if_parseable(code, fn, ...)
```

#### Arguments

- **`code`**: Code string.
- **`fn`**: Transform function taking `code` as first argument.
- **`...`**: Additional arguments passed to `fn`.

#### Value

Transformed code if parseable, otherwise original code.


## col_to_charpos

### Convert Tab-Expanded Column to Character Position

#### Description

R's getParseData() reports columns with tabs expanded to 8-column tab stops.
This function converts such a column back to a character position for use
with substring().

#### Usage

```r
col_to_charpos(line, col)
```

#### Arguments

- **`line`**: A single line of text.
- **`col`**: Tab-expanded column position (1-based).

#### Value

Character position (1-based) in the string.


## collapse_calls

### Collapse Multi-Line Function Calls

#### Description

Collapses function calls spanning multiple lines into a single line.
Long lines are re-wrapped by `wrap_long_calls()` afterward. For example:
c(x,
y,
z
)
becomes `c(x, y, z)`.

#### Usage

```r
collapse_calls(code)
```

#### Arguments

- **`code`**: Formatted code string.

#### Value

Code with collapsed function calls.


## collapse_one_call

### Collapse One Multi-Line Function Call

#### Description

Finds the first multi-line function call that can fit on one line
and collapses it. Skips calls containing comments.

#### Usage

```r
collapse_one_call(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Modified code or NULL if no changes.


## compute_indent_at_col

### Compute Indent at a Column Position

#### Description

Walks tokens on a line up to a given column, tracking braces and parens
exactly as compute_nesting does. Returns the indent level that a
hypothetical continuation line would receive.

#### Usage

```r
compute_indent_at_col(nesting, line_toks, line_num, break_col)
```

#### Arguments

- **`nesting`**: Result from compute_nesting().
- **`line_toks`**: Tokens on the line.
- **`line_num`**: Line number.
- **`break_col`**: Column position to stop at (inclusive).

#### Value

Integer indent level.


## compute_nesting

### Compute Nesting Depth Per Line

#### Description

Shared function used by `format_tokens` and wrap passes to compute
identical depth-based indent levels from the parse tree.

#### Usage

```r
compute_nesting(terminals, n_lines)
```

#### Arguments

- **`terminals`**: Terminal token data frame from `getParseData()`,
ordered by `line1, col1`.
- **`n_lines`**: Number of source lines.

#### Value

Named list with `line_indent`, `line_end_brace`,
  `line_end_paren`, `line_end_pab` (all integer vectors of length
  `n_lines`).


## display_width

### Get Tab-Expanded Line Length

#### Description

Returns the display width of a line, with tabs expanded to 8-column stops.

#### Usage

```r
display_width(line)
```

#### Arguments

- **`line`**: A single line of text.

#### Value

Display width of the line.


## expand_call_if_args

### Expand Bare If-Else Arguments in Function Calls

#### Description

When a function call has a bare `if (cond) expr else expr` argument
that doesn't fit on a continuation line, expand it to braced multi-line
form. Short if-else args stay inline.

#### Usage

```r
expand_call_if_args(code, line_limit = 80L)
```

#### Arguments

- **`code`**: Formatted code string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Code with expanded if-else call arguments.


## expand_one_call_if_arg

### Expand One Bare If-Else Argument in a Function Call

#### Description

Finds the first bare if-else argument inside a function call on a line
exceeding the line limit and expands it to braced multi-line form.

#### Usage

```r
expand_one_call_if_arg(code, line_limit = 80L)
```

#### Arguments

- **`code`**: Code string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Modified code or NULL if no changes.


## extract_expr_text

### Extract Expression Text from Source Lines

#### Description

Extract original text for a multi-line expression and re-indent it.

#### Usage

```r
extract_expr_text(lines, tokens, target_indent)
```

#### Arguments

- **`lines`**: Source code lines.
- **`tokens`**: Token data frame for the expression.
- **`target_indent`**: Target indentation string for continuation lines.

#### Value

Expression text with first line unindented, continuation lines re-indented.


## find_token_pos_in_formatted

### Find Token Position in Formatted Line Output

#### Description

Computes the 1-based character position where the token at index `idx`
starts in the output of `format_line_tokens(tokens)`. This replays the
spacing logic to determine the exact output column.

#### Usage

```r
find_token_pos_in_formatted(tokens, idx)
```

#### Arguments

- **`tokens`**: Data frame of tokens for one line (ordered by col1).
- **`idx`**: Index into `tokens` of the target token.

#### Value

1-based character position of that token in the formatted output.


## fix_else_placement

### Fix Else Placement

#### Description

Ensures `else` appears on the same line as the closing brace.

#### Usage

```r
fix_else_placement(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Code with corrected else placement.


## format_blank_lines

### Format Blank Lines

#### Description

Normalize blank lines between code blocks.

#### Usage

```r
format_blank_lines(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

Code with normalized blank lines.


## format_line_tokens

### Format Tokens on a Single Line

#### Description

Format Tokens on a Single Line

#### Usage

```r
format_line_tokens(tokens, prev_token = NULL, prev_prev_token = NULL)
```

#### Arguments

- **`tokens`**: Data frame of tokens for one line.
- **`prev_token`**: Optional token to treat as the previous token when
formatting a token subset (e.g., suffix after a collapsed call).
- **`prev_prev_token`**: Optional token before prev_token for unary detection.

#### Value

Formatted line content (no leading whitespace).


## format_pipeline

### Apply Formatting Pipeline to a Code Fragment

#### Description

Runs collapse, brace, wrap, function-def, and inline-if passes on a
single code string. Designed to operate on individual top-level
expressions so each gets the full iteration budget.

#### Usage

```r
format_pipeline(code, indent, wrap, expand_if, brace_style, line_limit)
```

#### Arguments

- **`code`**: Character string of R code.
- **`indent`**: Indent size or string.
- **`wrap`**: Continuation style.
- **`expand_if`**: Expand inline if-else.
- **`brace_style`**: Brace placement style.
- **`line_limit`**: Maximum line length.

#### Value

Formatted code string.


## format_tokens

### Format R Code Using Token-Based Parsing

#### Description

Internal function to format R code using getParseData tokens.
Calculates proper indentation based on nesting depth.

#### Usage

```r
format_tokens(
  code,
  indent = 4L,
  wrap = "paren",
  expand_if = FALSE,
  brace_style = "kr",
  line_limit = 80L
)
```

#### Arguments

- **`code`**: Character string of R code.
- **`indent`**: Integer for spaces (default 4), or character string for
literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`wrap`**: Continuation style: `"paren"` (default) aligns to opening
parenthesis, `"fixed"` uses 8-space indent.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`brace_style`**: Brace placement: `"kr"` (same line) or `"allman"` (new line).
- **`line_limit`**: Maximum line length before wrapping (default 80).

#### Value

Formatted code as character string.


## is_parseable_code

### Parse Gate for Transform Passes

#### Description

Parse Gate for Transform Passes

#### Usage

```r
is_parseable_code(code)
```

#### Arguments

- **`code`**: Code string.

#### Value

TRUE if code parses, FALSE otherwise.


## needs_space

### Determine If Space Needed Between Tokens

#### Description

Determine If Space Needed Between Tokens

#### Usage

```r
needs_space(prev, tok, prev_prev = NULL)
```

#### Arguments

- **`prev`**: Previous token (data frame row).
- **`tok`**: Current token (data frame row).
- **`prev_prev`**: Token before prev (data frame row or NULL), for unary detection.

#### Value

Logical.


## reformat_function_defs

### Reformat Function Definitions

#### Description

Ensures function definitions follow style guide:
- Short signatures on one line
- Long signatures wrap with continuation indent
- Brace on same line (K&R) or own line (Allman)

#### Usage

```r
reformat_function_defs(
  code,
  wrap = "paren",
  brace_style = "kr",
  line_limit = 80L
)
```

#### Arguments

- **`code`**: Formatted code string.
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`brace_style`**: Brace placement: `"kr"` (same line) or `"allman"` (new line).
- **`line_limit`**: Maximum line length before wrapping (default 80).

#### Value

Code with reformatted function definitions.


## reformat_inline_if

### Reformat Inline If-Else Statements

#### Description

Expands inline if-else to multi-line format per style guide:
x <- if (cond) a else b
becomes:
if (cond) {
x <- a
} else {
x <- b

#### Usage

```r
reformat_inline_if(code, line_limit = 0L)
```

#### Arguments

- **`code`**: Formatted code string.
- **`line_limit`**: Only expand if-else on lines exceeding this limit.
Use 0 to expand all inline if-else.

#### Value

Code with reformatted inline if-else.


## reformat_one_function

### Reformat One Function Definition

#### Description

Uses R Core continuation style: args on one line if they fit,
otherwise wrap with continuation indent.

#### Usage

```r
reformat_one_function(
  code,
  wrap = "paren",
  brace_style = "kr",
  line_limit = 80L
)
```

#### Arguments

- **`code`**: Code string.
- **`wrap`**: Continuation style: `"paren"` aligns to opening parenthesis,
`"fixed"` uses 8-space indent.
- **`brace_style`**: Brace placement: `"kr"` (same line) or `"allman"` (new line).
- **`line_limit`**: Maximum line length before wrapping (default 80).

#### Value

Modified code or NULL if no changes.


## reformat_one_inline_if

### Reformat One Inline If-Else Statement

#### Description

Reformat One Inline If-Else Statement

#### Usage

```r
reformat_one_inline_if(code, line_limit = 0L)
```

#### Arguments

- **`code`**: Code string.
- **`line_limit`**: Only expand if-else on lines exceeding this limit.
Use 0 to expand all inline if-else.

#### Value

Modified code or NULL if no changes.


## restore_truncated_str_const_tokens

### Restore Truncated String Constant Token Text

#### Description

`utils::getParseData()` truncates long `STR_CONST` token text. Reconstruct the
original literal from source lines so token-based rewrite passes can round-trip
long strings without introducing parse-invalid placeholders.

#### Usage

```r
restore_truncated_str_const_tokens(terminals, orig_lines)
```

#### Arguments

- **`terminals`**: Terminal token data frame from `getParseData()`.
- **`orig_lines`**: Original source lines.

#### Value

`terminals` with long `STR_CONST` text restored.


## rformat_dir

### Format R Files in Directory

#### Description

Format all R files in a directory.

#### Usage

```r
rformat_dir(
  path = ".",
  recursive = TRUE,
  dry_run = FALSE,
  indent = 4L,
  wrap = "paren",
  expand_if = FALSE,
  brace_style = "kr",
  line_limit = 80L
)
```

#### Arguments

- **`path`**: Path to directory.
- **`recursive`**: If TRUE, process subdirectories.
- **`dry_run`**: If TRUE, report changes without writing.
- **`indent`**: Indentation per level: integer for spaces (default 4), or
character string for literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`wrap`**: Continuation style for long function signatures: `"paren"`
(default) aligns to opening parenthesis, `"fixed"` uses 8-space indent.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`brace_style`**: Brace placement for function definitions: `"kr"` (default)
puts opening brace on same line as `) {`, `"allman"` puts it on a new line.
- **`line_limit`**: Maximum line length before wrapping (default 80).

#### Value

Invisibly returns vector of modified file paths.

#### Examples

```r
# Format all R files in a directory (dry run)
d <- tempfile()
dir.create(d)
writeLines("x<-1", file.path(d, "test.R"))
rformat_dir(d, dry_run = TRUE)

# Format and overwrite
rformat_dir(d)
unlink(d, recursive = TRUE)
```


## rformat_file

### Format R File

#### Description

Format an R file in place or write to a new file.

#### Usage

```r
rformat_file(
  path,
  output = NULL,
  dry_run = FALSE,
  indent = 4L,
  wrap = "paren",
  expand_if = FALSE,
  brace_style = "kr",
  line_limit = 80L
)
```

#### Arguments

- **`path`**: Path to R file.
- **`output`**: Optional output path. If NULL, overwrites input file.
- **`dry_run`**: If TRUE, return formatted code without writing.
- **`indent`**: Indentation per level: integer for spaces (default 4), or
character string for literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`wrap`**: Continuation style for long function signatures: `"paren"`
(default) aligns to opening parenthesis, `"fixed"` uses 8-space indent.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`brace_style`**: Brace placement for function definitions: `"kr"` (default)
puts opening brace on same line as `) {`, `"allman"` puts it on a new line.
- **`line_limit`**: Maximum line length before wrapping (default 80).

#### Value

Invisibly returns formatted code.

#### Examples

```r
# Format a file (dry run to see result without writing)
f <- tempfile(fileext = ".R")
writeLines("x<-1+2", f)
rformat_file(f, dry_run = TRUE)

# Format and overwrite
rformat_file(f)
readLines(f)
unlink(f)
```


## rformat

### Format R Code

#### Description

Format R code string according to base R style conventions.

#### Usage

```r
rformat(
  code,
  indent = 4L,
  wrap = "paren",
  expand_if = FALSE,
  brace_style = "kr",
  line_limit = 80L
)
```

#### Arguments

- **`code`**: Character string of R code to format.
- **`indent`**: Indentation per level: integer for spaces (default 4), or
character string for literal indent (e.g., `"\t\t"` for vintage R Core style).
- **`wrap`**: Continuation style for long function signatures: `"paren"`
(default) aligns to opening parenthesis, `"fixed"` uses 8-space indent.
- **`expand_if`**: Expand inline if-else to multi-line (default FALSE).
- **`brace_style`**: Brace placement for function definitions: `"kr"` (default)
puts opening brace on same line as `) {`, `"allman"` puts it on a new line.
- **`line_limit`**: Maximum line length before wrapping (default 80).

#### Value

Formatted code as a character string.

#### Examples

```r
rformat("x<-1+2")
rformat("if(x>0){y<-1}")
# Expand inline if-else
rformat("x <- if (a) b else c", expand_if = TRUE)
# Allman brace style (legacy)
rformat("f <- function(x) { x }", brace_style = "allman")
```


## split_toplevel

### Split Code into Top-Level Expressions

#### Description

Parses code to find top-level expressions, returning a list of chunks.
Each chunk is either an expression (code string) or an inter-expression
gap (comments, blank lines). Chunks concatenate back to the original.

#### Usage

```r
split_toplevel(code)
```

#### Arguments

- **`code`**: Character string of R code.

#### Value

List of `list(text = "...", is_expr = TRUE/FALSE)` pairs.


## wrap_long_calls

### Wrap Long Function Calls

#### Description

Wraps function call lines that exceed the line limit by breaking at commas.
Continuation lines are aligned to the opening parenthesis.

#### Usage

```r
wrap_long_calls(code, wrap = "paren", indent = 4L, line_limit = 80L)
```

#### Arguments

- **`code`**: Formatted code string.
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`indent`**: Indent size (integer) or string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Code with wrapped long calls.


## wrap_long_operators

### Wrap Long Lines at Operators

#### Description

Wraps lines exceeding the line limit at logical operators (`||`, `&&`)
with continuation aligned to the first operand.

#### Usage

```r
wrap_long_operators(code, indent = 4L, line_limit = 80L)
```

#### Arguments

- **`code`**: Formatted code string.
- **`indent`**: Indent size (integer) or string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Code with wrapped long lines.


## wrap_one_long_call

### Wrap One Long Function Call

#### Description

Finds the first single-line function call that exceeds the line limit
and wraps it at commas with paren-aligned continuation.

#### Usage

```r
wrap_one_long_call(code, wrap = "paren", indent = 4L, line_limit = 80L)
```

#### Arguments

- **`code`**: Code string.
- **`wrap`**: Continuation style: `"paren"` or `"fixed"`.
- **`indent`**: Indent size (integer) or string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Modified code or NULL if no changes.


## wrap_one_long_operator

### Wrap One Long Line at an Operator

#### Description

Finds the first line exceeding the limit that contains a top-level
logical operator and wraps there. The operator stays at the end of the
first line, continuation is aligned to the first operand.

#### Usage

```r
wrap_one_long_operator(code, indent = 4L, line_limit = 80L)
```

#### Arguments

- **`code`**: Code string.
- **`indent`**: Indent size (integer) or string.
- **`line_limit`**: Maximum line length (default 80).

#### Value

Modified code or NULL if no changes.


